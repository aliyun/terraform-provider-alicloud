package sls

import (
	"math/rand"
	"testing"
	"time"

	clz4 "github.com/cloudflare/golz4"
	"github.com/golang/glog"
	"github.com/pierrec/lz4"
	"github.com/stretchr/testify/suite"
)

func TestLz4(t *testing.T) {
	suite.Run(t, new(Lz4TestSuite))
	glog.Flush()
}

type Lz4TestSuite struct {
	suite.Suite
}

func (s *Lz4TestSuite) TestCompress() {
	rand.Seed(time.Now().Unix())
	body := make([]byte, 0, 1024)
	lastLen := 0
	for i := 1; i <= 102410; i += rand.Int() % 10240 {
		// Compresse body with lz4
		for lastLen < i {
			body = append(body, byte(rand.Int()))
			lastLen++
		}
		out := make([]byte, lz4.CompressBlockBound(len(body)))
		var hashTable [1 << 16]int
		n, err := lz4.CompressBlock(body, out, hashTable[:])
		s.Nil(err)

		// copy incompressible data as lz4 format
		if n == 0 {
			n, _ = copyIncompressible(body, out)
		}

		checkBody := make([]byte, len(body))
		s.Nil(clz4.Uncompress(out[0:n], checkBody))
		for j := 0; j < i; j++ {
			s.Equal(body[j], checkBody[j])
		}
	}
}

func (s *Lz4TestSuite) TestUnCompress() {
	rand.Seed(time.Now().Unix())
	body := make([]byte, 0, 1024)
	lastLen := 0
	for i := 1; i <= 1024100; i += rand.Int() % 10240 {
		// Compresse body with lz4
		for lastLen < i {
			body = append(body, byte(rand.Int()))
			lastLen++
		}
		out := make([]byte, clz4.CompressBound(body))
		n, err := clz4.Compress(body, out)
		s.Nil(err)

		checkBody := make([]byte, len(body))
		l, err := lz4.UncompressBlock(out[0:n], checkBody)
		s.Nil(err)
		s.Equal(l, len(body))
		for j := 0; j < i; j++ {
			s.Equal(body[j], checkBody[j])
		}
	}
}
